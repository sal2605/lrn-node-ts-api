NOTES D'APPRENTISSAGE :

**********Pour installer TypeScript :**********
npm install -g typescript
tsc -v

**********Initialiser un projet Express avec TypeScript **********
- on crÃ©e le dossier du projet et aprÃ¨s on fait : 
| Pour initialiser un projet Node.js :
npm init -y 

| Installer les dÃ©pendances 
On installe Express, Sequelize et les outils nÃ©cessaires :
npm install express sequelize mysql2 dotenv cors jsonwebtoken bcryptjs

Et les types pour TypeScript :
npm install --save-dev typescript @types/express @types/jsonwebtoken @types/bcryptjs

********** CONFIGURER TYPESCRIPT **********
Dans le projet, tape :
tsc --init

Ã‡a va crÃ©er un fichier tsconfig.json, modifie-le comme Ã§a :

{
  "compilerOptions": {
    "target": "ES6",
    "module": "CommonJS",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true
  }
}

**********CrÃ©er le serveur Express**********
On crÃ©e un dossier src et dedans on crÃ©e un fichier server.ts dans lequel on met du code Ã  executer 
| Explication du code
import express : On importe Express.
dotenv.config() : Charge les variables dâ€™environnement.
app.use(express.json()) : Permet de lire les requÃªtes JSON.
app.get("/") : Une route simple qui retourne un message.
app.listen(PORT, () => {...}) : DÃ©marre le serveur.

**********Lancer le serveur**********
Dans le terminal, on met : 
npx ts-node src/server.ts

********** Sequelize : Connexion Ã  une base de donnÃ©es **********
Sequelize, c'est comme Eloquent de Laravel 
On va utiliser Sequelize avec MySql.
CrÃ©e un dossier config et dedans, un fichier database.ts pour la connexion Ã  la base de donnÃ©es.

**********CrÃ©er un modÃ¨le Sequelize********** 
CrÃ©er un dossier models et dedans un fichier User.ts. 
| Explication
class User extends Model â†’ On crÃ©e un modÃ¨le Sequelize.
User.init({...}) â†’ On dÃ©finit les colonnes de la table.
DataTypes â†’ SpÃ©cifie les types des colonnes.

AJOUT D'UN FICHIER .env A LA RACINE DU PROJET POUR GERER LA CONNEXION AVEC LA BD MySQL 
DB_NAME=nom_de_ta_base
DB_USER=ton_utilisateur
DB_PASS=ton_mot_de_passe
DB_HOST=localhost

********** CRUD API : Routes utilisateurs********** 
CrÃ©e un dossier routes et un fichier userRoutes.ts. 
userRoutes gÃ¨re les routes liÃ©es au model User 

| Pour pouvoir executer des commandes de creation de models, migrations et autres, on doit installer Sequelize CLI : 
Dans le terminal, on tape :
npm install --save-dev sequelize-cli

********** CONNEXION A UNE BASE DE DONNEES (MySQL) | on y va avec Node Js [node] **********
| On rÃ©initialise Sequelize en JavaScript 
npx sequelize-cli init

| Modifier config/config.js (au lieu de config.json) 
On transforme config/config.json en config/config.js et configure la connexion Ã  MySQL : 
Voici un exemple de contenu pour la connexion : 
---------------------------------------------------------------------
require('dotenv').config(); // Charge les variables d'environnement

module.exports = {
  development: {
    username: process.env.DB_USER || "root",
    password: process.env.DB_PASS || null,
    database: process.env.DB_NAME || "api_db",
    host: process.env.DB_HOST || "127.0.0.1",
    dialect: "mysql",
    logging: false,
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: "mysql",
    logging: false,
  },
};
---------------------------------------------------------------------
On s'assure d'avoir toutes les infos configurÃ©es dans le .env 

| Modifier models/index.js pour utiliser le config/config.js (c'etait config.js qui etait configurÃ©)
Modification de sequelize : 
---------------------------------------------------------------------
const { Sequelize } = require("sequelize");
const config = require("../config/config.js")[process.env.NODE_ENV || "development"];

const sequelize = new Sequelize(config.database, config.username, config.password, {
  host: config.host,
  dialect: config.dialect,
  logging: config.logging,
});
--------------------------------------------------------------------

| VÃ©rification de la connexion Ã  la base de donnÃ©es 
On ajoute un test de connexion en crÃ©ant testDb.js Ã  la racine ou dans un dossier : 
contenu du fichier "testDb.js" : 
--------------------------------------------------------------------
const sequelize = require("./models/index.js");

sequelize
  .authenticate()
  .then(() => console.log("âœ… Connexion rÃ©ussie Ã  la base de donnÃ©es"))
  .catch((err) => console.error("âŒ Erreur de connexion :", err));
--------------------------------------------------------------------

| puis on execute : node testDb.js 

| Apres que la connexion soit passÃ©e, on peut maintenant executer des commandes en rapport avec la BD : 
- Ajout d'un model et d'une migration : 
--------------------------------------------------------------------
npx sequelize-cli model:generate --name User --attributes name:string,email:string,password:string
--------------------------------------------------------------------
Cela va crÃ©er :
models/user.js
migrations/YYYYMMDDHHMMSS-create-user.js 

| Puis on peut executer la migration avec : 
--------------------------------------------------------------------
npx sequelize-cli db:migrate
--------------------------------------------------------------------

VoilÃ  maintenant les models et autres Ã©lÃ©ments de la base de donnÃ©es sont gÃ©rÃ©s ailleurs et le typescript est dans le dossier src; 
Dans le cas actuel, on doit importer le model User(gÃ©rÃ© dans models/User.js), dans le fichier des routes (userRoutes dans le cas actuel) 
--------------------------------------------------------------------
const { User } = require("../../models"); 
--------------------------------------------------------------------
// et ensuite utiliser User dans la suite du code. 

-- Actuellement dans le projet, j'ai deux fichiers de connexion Ã  la base de donnÃ©es : src/config/database.ts et config/config.js via models/index.js | c'est parce que le typescript ne me permettait pas d'interagir avec la base de donnÃ©es en paix, que j'ai decidÃ© d'utiliser les vraies commandes des documentations de sequelize, c'est avec Node Js et tout marche tres bien. Du coup je vais supprimer la connexion src/config/database.ts et partout utiliser la connexion sequelize initialisÃ©e grÃ¢ce Ã  config/config.js dans models/index.js. 

| Pour tester ces APIs avec PostMan, on doit renseigner les parametres en mode raw, sous format json, et au cas dans les headers pour la sortie, le content type serait pas bien configurÃ© on ajoute en headers : Content-Type: application/json 

--------------------------------------------------------------------

***** Dotenv : pour gerer les variables d'environnement 
s'il n'etait pas installÃ©, on l'aurait installÃ© avec la commande suivante : 
--------------------------------------------------------------------
npm install dotenv | ensuite on crÃ©era le fichier .env Ã  la racine du projet 
--------------------------------------------------------------------
| Chargement de dotenv dans le fichier de base (ici : server.ts) : 
--------------------------------------------------------------------
import dotenv from 'dotenv';
-------------------------------------------------------------------- 
dotenv.config() | Pour charger les variables d'environnement depuis le .env 
--------------------------------------------------------------------

***** Hash des mots de passe avec bcrypt : On ne stocke jamais un password en clair

| Installation de bcrypt s'il n'etait pas deja installÃ© 
--------------------------------------------------------------------
npm install bcrypt
npm install -D @types/bcrypt
--------------------------------------------------------------------

| Hash d'un mot de passe 
--------------------------------------------------------------------
import bcrypt from 'bcrypt';

User.beforeCreate(async (user) => {
  user.password = await bcrypt.hash(user.password, 10);
});
--------------------------------------------------------------------

| Verification du mot de passe 
--------------------------------------------------------------------
const isMatch = await bcrypt.compare(motDePasseSaisi, user.password);
if (!isMatch) {
  return res.status(401).json({ message: "Mot de passe incorrect" });
}
--------------------------------------------------------------------

***** MISE EN PLACE DE L'AUTHENTIFICATION JWT 

| Installation s'il etait pas installÃ© 
--------------------------------------------------------------------
npm install jsonwebtoken
npm install -D @types/jsonwebtoken
--------------------------------------------------------------------

| GÃ©nÃ©ration d'un token aprÃ¨s connexion :
Dans auth.controller.ts :
--------------------------------------------------------------------
import jwt from 'jsonwebtoken';

const token = jwt.sign(
  { id: user.id, email: user.email }, 
  process.env.JWT_SECRET as string, 
  { expiresIn: "1h" }
);
res.json({ token });
--------------------------------------------------------------------

| VÃ©rification du token dans un middleware 
* On crÃ©e middleware/auth.ts : 
--------------------------------------------------------------------
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export const verifyToken = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return res.status(403).json({ message: "AccÃ¨s refusÃ©" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET as string);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ message: "Token invalide" });
  }
};
--------------------------------------------------------------------
* On ajoute ce middleware sur les routes protÃ©gÃ©es :
--------------------------------------------------------------------
router.get('/profile', verifyToken, (req, res) => {
  res.json({ message: "Profil sÃ©curisÃ©", user: req.user });
});
--------------------------------------------------------------------

***** CREATION DU SYSTEME D'AUTHENTIFICATION (INSCRIPTION + CONNEXION) 
ğŸ“Œ Route dâ€™inscription
Dans auth.routes.ts :
--------------------------------------------------------------------
router.post('/register', async (req, res) => {
  const { name, email, password } = req.body;
  try {
    const user = await User.create({ name, email, password });
    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ message: "Erreur lors de l'inscription", error });
  }
});
--------------------------------------------------------------------

ğŸ“Œ Route de connexion
--------------------------------------------------------------------
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ where: { email } });
  if (!user) return res.status(404).json({ message: "Utilisateur introuvable" });

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) return res.status(401).json({ message: "Mot de passe incorrect" });

  const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET as string, { expiresIn: "1h" });
  res.json({ token });
});
--------------------------------------------------------------------

************ VALIDATION DES DONNEES AVEC express-validator ************ 

ğŸ“Œ 1. Installation des dÃ©pendances
--------------------------------------------------------------------
npm install express-validator bcrypt jsonwebtoken
npm install --save-dev @types/jsonwebtoken
--------------------------------------------------------------------

ğŸ“Œ 2. CrÃ©ation du contrÃ´leur AuthController.ts
On crÃ©e le fichier src/controllers/AuthController.ts et on ajoute son contenu,
| Dans ce fichier, on mettra les fonctions des routes d'authentification, la fonction qu'on doit par exemple mettre dans la route d'inscription, on mettra son code dans le controller et on l'appelera dans la route d'inscription.

ğŸ“Œ 3. CrÃ©ation des validations avec express-validator
| On crÃ©e src/middlewares/authValidation.ts et on ajoute les fonctions de validation faites avec express-validator.
| C'est comme pour les fonctions dans les controllers aussi, on ecrira leurs fonctions dans des fichiers middlewares de validation et on les importera dans les routes juste derriÃ¨re les fonctions des routes mÃªmes. 

ğŸ“Œ 4. CrÃ©ation des routes dâ€™authentification 
| On crÃ©e src/routes/authRoutes.ts et on ajoute les routes avec Router, on met les routes dans les fichiers des routes comme dans web.php avec laravel et on ajoute les fonctions importÃ©es depuis les controllers, mais c'est quand mÃªme un peu different, par exemple les validations sont ajoutÃ©es directement dans les routes aussi. 

ğŸ“Œ 5. Protection des routes avec JWT
| On crÃ©e src/middlewares/authMiddleware.ts et on ajoute le code.

ğŸ“Œ 6. Ajout des routes dans server.ts 
| Dans src/server.ts, on importe les fichiers routes nÃ©cessaires et on ajoute le code qu'il faut. 