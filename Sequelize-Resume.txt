Les M√©thodes de Sequelize pour Interagir avec la Base de Donn√©es üî•
---------------------------------------------------------------------------------------
üîπ 1. CRUD : Create, Read, Update, Delete

***** CREATE ***** | INSERT : Ins√®re un nouvel enregistrement dans la BD et retourne l'instance cr√©√©e
--------------------------------------------------------------------
const user = await User.create({
  name: "John Doe",
  email: "john@example.com",
  password: "hashed_password"
});
--------------------------------------------------------------------

***** READ ***** | SELECT 
Ex:
--------------------------------------------------------------------
const users = await User.findAll(); // R√©cup√®re tous les utilisateurs
const user = await User.findOne({ where: { email: "john@example.com" } }); // Un seul utilisateur
const userById = await User.findByPk(1); // Trouver par ID
--------------------------------------------------------------------

***** UPDATE ***** | .update(data, { where }) ‚Üí Met √† jour l‚Äôenregistrement qui correspond √† where. 
Ex:
--------------------------------------------------------------------
await User.update(
  { name: "Jane Doe" }, 
  { where: { id: 1 } }
);
--------------------------------------------------------------------

***** DELETE ***** | .destroy({ where }) ‚Üí Supprime les enregistrements qui correspondent √† where.
Ex:
--------------------------------------------------------------------
await User.destroy({ where: { id: 1 } });
--------------------------------------------------------------------

üîπ 2. Op√©rateurs Sequelize pour les Conditions (Op) 
| Sequelize fournit des op√©rateurs pour cr√©er des requ√™tes avanc√©es. 
Ex:
--------------------------------------------------------------------
import { Op } from "sequelize";

const users = await User.findAll({
  where: {
    age: { [Op.gte]: 18 }, // age >= 18
    name: { [Op.like]: "%John%" } // LIKE '%John%'
  }
});
--------------------------------------------------------------------

üîë Liste des principaux op√©rateurs :
----------------------------------------------------------
| Op√©rateur   |                 Explication              |
----------------------------------------------------------
| Op.eq	      |   = (√âgal)                               |
| Op.ne	      |   != (Diff√©rent)                         |
| Op.gt	      |   > (Sup√©rieur)                          |
| Op.gte	  |   >= (Sup√©rieur ou √©gal)                 |
| Op.lt	      |   < (Inf√©rieur)                          |
| Op.lte	  |   <= (Inf√©rieur ou √©gal)                 |
| Op.like	  |   LIKE '%valeur%' (Recherche partielle)  |
----------------------------------------------------------

üîπ 3. Requ√™tes Relationnelles (Jointures) | Include (comme le concept de with() en LARAVEL)
Si User a une relation avec Post (User.hasMany(Post);), on peut r√©cup√©rer un utilisateur avec ses articles (include fait une jointure).
Ex:
--------------------------------------------------------------------
const userWithPosts = await User.findOne({
  where: { id: 1 },
  include: { model: Post, as: "posts" } // Charge les posts associ√©s √† l‚Äôutilisateur.
});
--------------------------------------------------------------------

üîπ 4. Transactions (S√©curiser plusieurs requ√™tes) | comme DB transaction en LARAVEL 
Si on veut ex√©cuter plusieurs op√©rations dans une transaction (si une √©choue, tout est annul√©), on utilise transaction. 
Ex:
--------------------------------------------------------------------
import { sequelize } from "../models";

const transaction = await sequelize.transaction(); // Cr√©er une transaction
try {
  const user = await User.create({ name: "Alex" }, { transaction });
  await Post.create({ title: "Mon Post", userId: user.id }, { transaction });

  await transaction.commit(); // Valider la transaction
} catch (error) {
  await transaction.rollback(); // Annuler la transaction si une requ√™te √©choue.
}
--------------------------------------------------------------------

üìå R√©capitulatif des m√©thodes Sequelize
----------------------------------------------------------------------------------------
| M√©thodes                          | Fonctions                                        |
----------------------------------------------------------------------------------------
| .create(data)                     | Cr√©er un enregistrement                          |
| .findAll()                        | R√©cup√©rer tous les enregistrements               |
| .findOne({ where })               | R√©cup√©rer un enregistrement sp√©cifique           |
| .findByPk(id)                     | R√©cup√©rer un enregistrement par ID               |
| .update(data, { where })          | Mettre √† jour un enregistrement                  |
| .destroy({ where })               | Supprimer un enregistrement                      |
| Op.eq, Op.gt, Op.like             | Op√©rateurs pour conditions                       |
| .include({ model: Model })        | Charger les relations (jointures)                |
| sequelize.transaction()           | Ex√©cuter plusieurs requ√™tes de mani√®re s√©curis√©e |
----------------------------------------------------------------------------------------

***** RELATIONS ENTRE MODELS EN SEQUELIZE *****

üìå Types de relations en Sequelize
Sequelize fonctionne comme Eloquent pour les relations. Voici les principaux types de relations :
--------------------------------------------------------------------
1Ô∏è‚É£ One-to-One (hasOne / belongsTo)
2Ô∏è‚É£ One-to-Many (hasMany / belongsTo)
3Ô∏è‚É£ Many-to-Many (belongsToMany) 
--------------------------------------------------------------------

Note : Pour chaque model, on met les relations dans la m√©thode "associate" 

********** One-to-One (hasOne / belongsTo) **********
Ex: Un utilisateur a un profil (User <-> Profile) 
| Dans le model User.js, on aura : 
--------------------------------------------------------------------
User.hasOne(models.Profile, { foreignKey: 'userId', as: 'profile' });
--------------------------------------------------------------------
| Et dans Profile.js, on aura :
--------------------------------------------------------------------
Profile.belongsTo(models.User, { foreignKey: 'userId', as: 'user' });
--------------------------------------------------------------------

********** One-to-Many (hasMany / belongsTo) **********
Ex: Un utilisateur peut avoir plusieurs produits (User <-> Product) 
| Dans le model User.js, on aura : 
--------------------------------------------------------------------
User.hasMany(models.Product, { foreignKey: 'userId', as: 'products' });
--------------------------------------------------------------------
| Et dans Product.js, on aura :
--------------------------------------------------------------------
Product.belongsTo(models.User, { foreignKey: 'userId', as: 'owner' });
--------------------------------------------------------------------
--------------------------------------------------------------------

********** Many-to-Many (belongsToMany) ********** 
Ex: Un utilisateur peut avoir plusieurs r√¥les et un r√¥le peut appartenir √† plusieurs utilisateurs (User <-> Role) 
--- Ici c'est un peu diff√©rent des autres relations, on aura une table pivot contenant les deux cl√©s (userId et roleId).
| Dans le model User.js, on aura : 
--------------------------------------------------------------------
User.belongsToMany(models.Role, { through: 'UserRoles', foreignKey: 'userId', as: 'roles' });
--------------------------------------------------------------------
| Et dans Role.js, on aura :
--------------------------------------------------------------------
Role.belongsToMany(models.User, { through: 'UserRoles', foreignKey: 'roleId', as: 'users' });
--------------------------------------------------------------------
| Le "through" qui s'ajoute pour les relations Many, c'est pour sp√©cifier le model Pivot.

---------------------------------------------------------------------------------------
| TRES INTERESSANT A SAVOIR SUR LES RELATIONS MANY-TO-MANY : 
--------------------------------------------------------------------
Une fois que tu d√©finis une relation many-to-many entre deux mod√®les, Sequelize g√©n√®re automatiquement des m√©thodes pratiques pour manipuler cette relation. Ces m√©thodes suivent un mod√®le pr√©√©tabli, et c‚Äôest pour √ßa que tu vois des m√©thodes comme addRole, getRoles, etc entre User et Role.

Si tu as une relation many-to-many entre User et Group, par exemple, Sequelize g√©n√®re automatiquement des m√©thodes similaires pour g√©rer cette relation.
Exemple avec User et Group :
--------------------------------------------------------------------
Si tu cr√©es une relation many-to-many entre User et Group avec une table pivot UserGroup, Sequelize g√©n√©rera des m√©thodes comme :
--------------------------------------------------------------------
* addGroup(groupId) : Ajoute un groupe √† un utilisateur.
* getGroups() : R√©cup√®re tous les groupes associ√©s √† un utilisateur.
* removeGroup(groupId) : Retire un groupe de l'utilisateur.
* setGroups(groups) : Remplace les groupes associ√©s √† l'utilisateur. 
--------------------------------------------------------------------
Ex. pour setGroups :
const newGroups = await Group.findAll(); // avec un where dedans on veut 
await user?.setGroups(newGroups);  
--------------------------------------------------------------------

| ********* ET C'EST PAREIL POUR LES AUTRES RELATIONS AUSSI ********* |
Ex. avec One-to-One : 
- On aura des m√©thodes comme setModel, getModel, et createModel.
* Avec User et Profile on peut avoir : 
--------------------------------------------------------------------
const user = await User.findByPk(1);
const profile = await Profile.create({ bio: 'Bio de l\'utilisateur' });

await user?.setProfile(profile); // Associer un profil √† l'utilisateur
--------------------------------------------------------------------

| ********* One-to-Many : PAREIL AUSSI ********* |

-----------------------------------------------------------------------------------------
| CHARGEMENT DES RELATIONS (include)
-----------------------------------------------------------------------------------------
Sequelize permet de r√©cup√©rer les relations avec include. 
Some Examples : 
---------------------------------------------------------------------------------------------------
| const user = await User.findByPk(req.params.id, { include: [{ model: Product, as: 'products' }, { model: Profile, as: 'profile' }, { model: Role, as: 'roles' }] }); // Quand on veut charger plusieurs relations, on ajoute les crochets []
| const product = await Product.findByPk(req.params.id, { include: { model: User, as: 'owner' } });
---------------------------------------------------------------------------------------------------

